\chapter{Klasse Backgammon}
Die Klasse \srcref[]{class BG::}{Backgammon}{ : public QObject;}{\wdir backgammon.h}{BG::Backgammon} implementiert den Programmkern. Sie ist in der Lage den aktuellen Spielstand eines Backgammon-Spiels zu speichern und stellt Funktionen bereit, um Züge auszuführen. Die Verteilung der Spielsteine wird mit den Variablen \srcref[]{short int BG::Backgammon::}{m_points}{[ 24 ];}{\wdir backgammon.h}{BG::Backgammon::m_points}, \srcref[]{short int BG::Backgammon::}{m_on_bar}{[ 2 ];}{\wdir backgammon.h}{BG::Backgammon::m_on_bar} und \srcref[]{short int BG::Backgammon::}{m_beared_off}{[ 2 ];}{\wdir backgammon.h}{BG::Backgammon::m_beared_off} gespeichert. Dabei gibt \srcref[]{short int BG::Backgammon::}{m_points}{[ 24 ];}{\wdir backgammon.h}{BG::Backgammon::m_points} die Verteilung der Spielsteine an: Positive Werte sind Spielsteine des weißen, negative Werte Spielsteine des schwarzen Spielers. Weiß zieht in Richtung der höheren Indizes des Array, Schwarz dementsprechend entgegengesetzt. Weiterhin wird mit \srcref[]{short int BG::Backgammon::}{m_on_bar}{[ 2 ];}{\wdir backgammon.h}{BG::Backgammon::m_on_bar} die Zahl der Steine auf der Bar und mit \srcref[]{short int BG::Backgammon::}{m_beared_off}{[ 2 ];}{\wdir backgammon.h}{BG::Backgammon::m_beared_off} die Zahl der ausgewürfelten Spielsteine gespeichert. Die Werte dieser beiden Arrays sind immer positiv und das Element mit dem Index $0$ ist jeweils die Angabe für den weißen Spieler, das Element mit dem Index $1$ für den schwarzen.

Für eine bessere Lesbarkeit des Sourcecodes habe ich die Enumeration \srcref[]{enum BG::}{Player}{;}{\wdir backgammon.h}{BG::Player} definiert, welche die Elemente \srcref[]{BG::}{WHITE}{ = 0;}{\wdir backgammon.h}{BG::WHITE} und \srcref[]{BG::}{BLACK}{ = 1;}{\wdir backgammon.h}{BG::BLACK} bereitstellt. Weiterhin stellt die Enumeration \srcref[]{enum BG::}{Position}{;}{\wdir backgammon.h}{BG::Position} die Werte \srcref[]{BG::}{BAR}{ = 24;}{\wdir backgammon.h}{BG::BAR} und \srcref[]{BG::}{OUT_OF_GAME}{ = 25;}{\wdir backgammon.h}{BG::OUT_OF_GAME} bereit, welche dazu dienen die Bar und die "`Position"' für ausgewürfelte Spielsteine zu bezeichnen.

Weiterhin speichert die Klasse \srcref[]{class BG::}{Backgammon}{ : public QObject;}{\wdir backgammon.h}{BG::Backgammon} in \srcref[]{BG::Player BG::Backgammon::}{m_act_player}{;}{\wdir backgammon.h}{BG::Backgammon::m_act_player} den aktuellen Spieler und im Array \srcref[]{short int BG::Backgammon::}{m_dice}{[ 4 ];}{\wdir backgammon.h}{BG::Backgammon::m_dice} die Augenzahlen, die maximal gesetzt werden können (unter Umständen kann nicht für alle gesetzt werden, da der Spieler vorher zugunfähig wird). Wenn nur noch für weniger als vier Augenzahlen gesetzt werden muss, wird den restlichen Array-Elementen der Wert $0$ zugewiesen.

Für das Übergeben von Zügen an Funktionen wird die Klasse \srcref[]{class BG::}{BackgammonMove}{;}{\wdir backgammon.h}{BG::BackgammonMove} verwendet. Sie speichert die Startposition und Zugweite eines Zuges. Mehrere solche Züge können mit der Klasse \srcref[]{class BG::}{BackgammonTurn}{;}{\wdir backgammon.h}{BG::BackgammonTurn} mit noch ein paar zusätzlichen Informationen zusammengefasst werden. Diese Klasse kommt bei der Speicherung der Zugliste zum Einsatz, auf die ich hier aber nicht näher eingehen werde.

\begin{sloppypar}
Auch wenn sich eine genauere Erklärung erübrigen dürfte, sollten die Funktionen \srcref{void BG::Backgammon::}{reset}{( void );}{\wdir backgammon.cpp}{void:BG::Backgammon::reset(void)} und \srcref{BG::WinHeight BG::Backgammon::}{calc_win_height}{( void );}{\wdir backgammon.cpp}{WinHeight:BG::Backgammon::calc_win_height(void)} erwähnt werden. Erstere setzt die Klasse zurück und startet so ein neues Backgammon-Spiel, letztere berechnet nach Beendigung eines Spiels die Gewinnhöhe.
\end{sloppypar}

Im Folgenden werde ich auf die Funktionen eingehen, welche feststellen, ob ein Spieler zugunfähig ist, ein Zug gültig ist, oder einen Zug ausführen. In vielen dieser Funktionen und auch einigen Funktionen, auf die ich hier nicht näher eingehe, wird die Konstante \lstinline$PLAYER_IND$ definiert. Wenn der aktuelle Spieler weiß ist, ist der Wert $1$, ansonsten $-1$. Dies ermöglicht es z.\,B.~if-Abfragen kompakter zu formulieren, da durch eine Multiplikation mit dieser Konstante derselbe Vergleich von Werten für beide Spieler verwendet werden kann.

Oft wird in diesen Funktionen zudem die Funktion \srcref{bool BG::Backgammon::}{is_able_to_move}{( const BG::BackgammonMove *move,$ \lstinline$const BackgammonMove *before ) const;}{\wdir backgammon.cpp}{bool:BG::Backgammon::is_able_to_move(const:BackgammonMove*,const:BackgammonMove*)const} aufgerufen. Sie prüft für einen übergebenen Zug, ob ein Spielstein vorhanden ist, der gezogen werden kann und das Zielfeld frei ist. Weiterhin kann der Funktion ein zweiter Zug übergeben werden, wobei die Funktion dann davon ausgeht, dass zuerst dieser Zug ausgeführt wird und dann prüft, ob der andere anschließend möglich ist. Ansonsten führt die Funktion aber keine weiteren Überprüfungen durch, ob der Zug gültig ist (beispielsweise wird nicht geprüft, ob von der Bar gezogen werden müsste).

\section{Feststellen, ob ein Spieler zugunfähig ist}
\label{topic:is_valid_move_possible} Die Funktion \srcref{bool BG::Backgammon::}{is_valid_move_possible}{( BG::BackgammonMove *move = NULL );}{\wdir backgammon.cpp}{bool:BG::Backgammon::is_valid_move_possible(BG::BackgammonMove*)} prüft, ob der aktuelle Spieler einen gültigen Zug ausführen kann. Wenn dies der Fall ist gibt sie \lstinline$true$, andernfalls \lstinline$false$, zurück. Zudem ist sie in der Lage gegebenenfalls einen gültigen Zug zurückzugeben. Diese spezielle Funktionalität wird von der KI verwendet, um sicherzustellen, dass sie in jedem Fall einen gültigen Zug ausführt.

\label{topic:m_dice_result_has_to_be_used} Das Setzen des Arrays \srcref[]{bool BG::Backgammon::}{m_dice_result_has_to_be_used}{[ 2 ];}{\wdir backgammon.h}{BG::Backgammon::m_dice_result_has_to_be_used} ist eine weitere wichtige Aufgabe der Funktion. Die beiden Elemente des Arrays liefern Informationen darüber, welche Augenzahlen gesetzt werden können. Ist \lstinline$m_dice_result_has_to_be_used[ 0 ]$ gleich \lstinline$true$ muss bzw. kann die höhere Augenzahl der beiden gewürfelten gesetzt werden. Wenn \lstinline$m_dice_result_has_to_be_used[ 1 ]$ wahr ist, muss die kleinere Augenzahl gesetzt werden. Ist einer dieser Werte \lstinline$false$ kann bzw. darf für die entsprechende Augenzahl nicht gesetzt werden. Bei einem Pasch sind beide Elemente wahr oder, sollte nur für eine Augenzahl gesetzt werden können, nur \lstinline$m_dice_result_has_to_be_used[ 0 ]$. Die Werte dieses Arrays werden von allen Funktionen verwendet, die prüfen, ob ein Zug gültig ist.

Die Arbeitsweise der Funktion \srcref{bool BG::Backgammon::}{is_valid_move_possible}{( BG::BackgammonMove *move );}{\wdir backgammon.cpp}{bool:BG::Backgammon::is_valid_move_possible(BG::BackgammonMove*)} unterscheidet sich, je nachdem für wieviele Augenzahlen evtl. noch gesetzt werden kann. Wenn für keine Augenzahl mehr gesetzt werden kann, so kehrt die Funktion sofort mit \lstinline$false$ zurück. Wenn maximal nur noch für eine Augenzahl gesetzt werden kann, wird zuerst geprüft, ob der Spieler noch Steine auf der Bar hat und ob es möglich ist davon einen zurück ins Spiel zu bringen. Wenn der Spieler keine Steine mehr auf der Bar hat, werden sämtliche "`Zungen"' durchgegangen und geprüft, ob von einer dieser "`Zungen"' die Augenzahl gezogen werden kann.

Hat der Spieler für zwei oder mehr Augenzahlen noch nicht gesetzt, wird es etwas komplizierter. Sollten noch mindestens zwei Steine auf der Bar sein, reicht es für beide Augenzahlen zu prüfen, ob es möglich ist, damit einen Spielstein wieder in das Spiel zu bringen.

Ist höchstens ein Spielstein auf der Bar, wird zuerst für jede der beiden Augenzahlen eine "`Zunge"' gesucht, von der diese Augenzahl gezogen werden kann. Dabei ist zu beachten, dass möglichst für beide Augenzahlen eine "`Zunge"' gefunden werden sollte. Falls dies nicht möglich ist, sollte möglichst für die größere der beiden Augenzahlen eine "`Zunge"' gefunden werden und, wenn das auch nicht geht, für die kleinere der beiden Augenzahlen. Dies habe ich so implementiert, dass alle Kombinationen von zwei "`Zungen"' $(a, b)$ durchgegangen werden (wobei $(a, b) \neq (b, a)$) und für jede dieser Kombinationen geprüft wird:
\begin{enumerate}
  \item Wenn die höhere Augenzahl von Position $a$ aus gesetzt werden kann\dots
    \begin{enumerate}[\theenumi.1.]
      \item Wenn vorher die höhere Augenzahl von Position $a$ gesetzt wurde und dann noch die niedrigere Augenzahl von Position $b$ gesetzt werden kann, wurde eine Zugkombination gefunden, die die Bedingungen bestmöglich erfüllt.
      \item Wenn vorher die höhere Augenzahl von Position $a$ gesetzt wurde, die niedrigere Augenzahl nicht mehr von Position $b$ gesetzt werden kann und noch keine anderere Position $a$ gefunden wurde, von der die höhere Augenzahl gesetzt werden kann, wurde eine Zugkombination gefunden, die die Bedingungen besser als die vorhergehenden Kombinationen erfüllt, aber noch nicht optimal ist.
    \end{enumerate}
  \item Wenn die höhere Augenzahl von Position $a$ aus nicht gesetzt werden kann, aber die niedrigere Augenzahl von Position $b$\dots
    \begin{enumerate}[\theenumi.1.]
      \item Wenn die höhere Augenzahl von Position $a$ gesetzt werden kann unter der Bedingung, dass die niedrigere Augenzahl von $b$ vorher gesetzt wurde, so wurde eine Zugkombination gefunden, die die Bedingungen bestmöglich erfüllt.
      \item Wenn die höhere Augenzahl auch dann nicht von Position $a$ gesetzt werden kann, wenn vorher die niedrigere Augenzahl von $b$ gesetzt wurde, und noch keine Position gefunden wurde, von der irgendeine der Augenzahlen gesetzt werden kann, dann wurde eine Zugkombination gefunden, die die obigen Bedingungen minimal erfüllt.
    \end{enumerate}
\end{enumerate}

Ist genau ein eigener Spielstein auf der Bar, wird erst geprüft, ob sich dieser mit der höheren Augenzahl ins Spiel zurückbringen lässt. Wenn sich dann noch die niedrigere Augenzahl von $b$ oder der wieder ins Spiel gebrachter Spielstein anschließend um diese Augenzahl setzen lässt, müssen beiden Augenzahlen verwendet werden und die Funktion kehrt zurück. Kann die niedrigere Augenzahl anschließend nicht gesetzt werden, wird mithilfe der Variable \lstinline$is_move_set$ vermerkt, dass mit der höheren Augenzahl der Spielstein ins Spiel gebracht werden kann. Wenn dieser nun mit der niedrigeren Augenzahl zurück gebracht werden kann und anschließend die höhere Augenzahl von $b$ oder mit dem zurückgebrachten Spielstein gesetzt werden kann, müssen beide Augenzahlen verwendet werden und die Funktion kann zurückkehren. Ist dies nicht der Fall und ist \lstinline$is_move_set$ wahr, muss für die größere Augenzahl gesetzt werden und für die kleinere kann nicht gesetzt werden. Ist \lstinline$is_move_set$ dagegen falsch (aber der Spielstein von der Bar kann mit der kleineren Augenzahl wieder ins Spiel gebracht werden), muss für die kleinere Augenzahl gesetzt werden und die größere kann nicht verwendet werden. Kann der Spielstein weder mit der höheren noch mit der niedrigeren Augenzahl ins Spiel zurückgebracht werden, ist der Spieler zugunfähig.

Sind keine Steine mehr auf der Bar, wird geprüft, ob eine Position $a$ gefunden wurde, von der die höhere Augenzahl gezogen werden kann. Wenn dann noch eine Position $b$ für die niedrigere Augenzahl gefunden wurde, muss für beide Augenzahlen gesetzt werden, andernfalls nur für die höhere. Wurde keine Position $a$ entsprechend der Bedingungen gefunden, aber eine Position $b$, muss für die kleinere Augenzahl gesetzt werden und für die größere ist dies nicht möglich.

Wenn jetzt noch kein gültiger Zug gefunden wurde, gibt die Funktion \lstinline$false$ zurück, da der Spieler zugunfähig ist.

\section{Gültigkeit eines Zuges feststellen}
Um zu prüfen, ob ein Zug gültig ist, wird die Funktion \srcref{bool BG::Backgammon::}{is_valid_move}{( const BG::BackgammonMove &move,$ \lstinline$ BG::IllegalMove *reason = NULL, bool *dice_used = NULL, bool check_bar = true );}{\wdir backgammon.cpp}{bool:BG::Backgammon::is_valid_move(const:BackgammonMove&,IllegalMove*,bool*,bool)const} verwendet. Bei dem übergebenen Zug dürfen mehrere Züge zusammengefasst werden, wenn z.\,B.~eine 1 sowie eine 4 gewürfelt wurden und von Position 3 über Position 4 zu Position 8 gezogen werden soll, kann ein Zug übergeben werden, dessen Startposition 3 und dessen Zugweite 5 ist. Die Funktion kann auch Informationen darüber zurückgeben, warum ein Zug nicht möglich ist oder welche Augenzahlen verwendet werden müssten, um den Zug auszuführen. In folgender Reihenfolge prüft die Funktion, ob der Zug gültig ist:
\begin{enumerate}
  \item Ist die Zugrichtung korrekt (bzw. ist die Zugweite positiv?)
  \item Sind noch Steine auf der Bar und wird in diesem Fall von der Bar gezogen?
  \item Ist auf der "`Zunge"', von der gezogen werden soll, überhaupt ein eigener Spielstein?
  \item Wird versucht den Spielstein auszuwürfeln?
    \begin{enumerate}[\theenumi.1.]
      \item Sind alle eigenen Spielsteine bereits im Homeboard?
      \item Wenn sich der Spielstein mit den gewürfelten Augenzahlen nicht passend auswürfeln lässt: Hat ein anderer Spielstein Vorrang?
    \end{enumerate}
  \item Ist das Zielfeld noch frei (bzw. höchstens ein gegnerischer Spielstein auf diesem)?
  \item Kann die Zugweite mit den gewürfelten Augenzahlen gesetzt werden?
\end{enumerate}

Der letzte Punkt ist etwas komplexer. Als erstes wird geprüft, ob die erste gewürfelte Augenzahl der Zugweite entspricht. Wenn dies der Fall ist könnte der Zug mit dieser Augenzahl ausgeführt werden. Allerdings muss noch geprüft werden, ob diese Augenzahl überhaupt verwendet werden darf (siehe dazu auch Kapitel \ref{topic:m_dice_result_has_to_be_used}). Muss auch noch für die andere Augenzahl gesetzt werden, wird noch überprüft, ob dies nach dem Zug noch immer möglich ist. Falls die erste gewürfelte Augenzahl nicht der Zugweite entspricht, wird das gleiche Schema für die zweite Augenzahl durchlaufen, sofern diese der Zugweite entspricht.

Sollte die Funktion noch nicht zurückgekehrt sein, muss für den Zug auf jeden Fall eine Kombination mindestens zweier Augenzahlen verwendet werden. Sollte mehr als ein Stein auf der Bar sein, ist der Zug ungültig, da erst alle Spielsteine zurück ins Spiel gebracht werden müssen bevor von woanders als der Bar gezogen werden darf.

Danach werden die jeweiligen "`Zwischenpositionen"' berechnet, als wenn für jeweils nur eine Augenzahl gesetzt werden würde. Diese dürfen nicht beide so groß sein, dass alleine mit einer Augenzahl der Spielstein, der gesetzt werden soll, ausgewürfelt würde. Denn dann würde bereits ein Würfel für den Zug reichen, aber die Funktion hat zu diesem Zeitpunkt bereits festgestellt, dass ein einzelner Würfel nicht reicht. Daher ist in diesem Fall der Zug ungültig.

Wenn nun die Summe der beiden Augenzahlen der Zugweite entspricht und eine der "`Zwischenpositionen"', wenn nur für eine Augenzahl gesetzt würde, frei ist, so ist der Zug gültig.

Wenn die Funktion zu diesem Zeitpunkt noch nicht zurückgekehrt ist, müssen in jedem Fall mindestens drei Augenzahlen verwendet werden. Dies ist nur bei einem Pasch möglich, woraus folgt, dass alle Augenzahlen gleich sind. Somit werden im nächsten Schritt die Augenzahlen durchgegangen und jeweils berechnet, welche "`Zunge"' zusammen mit den vorhergehenden Augenzahlen erreicht wird. Ist diese "`Zunge"' frei (oder auch wenn der Spielstein ausgewürfelt wird) kann die verbleibende Zugweite entsprechend verringert werden. Ist die restliche Zugweite danach null, so ist der Zug gültig. Wenn der Spielstein bereits ausgewürfelt sein sollte, bevor die restliche Zugweite null ist oder die Zugweite auch nach Durchgehen aller Augenzahlen nicht null ist, so ist der Zug ungültig.

\paragraph{Gültigkeit mehrer Züge gleichzeitig feststellen:} Mit \srcref{bool BG::Backgammon::}{are_valid_moves}{($ \lstinline$const std::vector< BG::BackgammonMove > &move, BG::IllegalMove *reason = NULL,$ \lstinline$bool **dice_used = NULL );}{\wdir backgammon.cpp}{bool:BG::Backgammon::are_valid_moves(const:std::vector:BackgammonMove&,IllegalMove*,bool**)const} steht eine Funktion bereit, die für mehrere Züge (die als \lstinline$std::vector$ übergeben werden) auf einmal prüft, ob diese gültig sind. Dazu wird eine Kopie des aktuellen Backgammon-Spiels erstellt und in einer Schleife wird so lange versucht die noch nicht gesetzten Züge zu setzen bis bei einem Schleifendurchlauf kein weiterer Zug mehr gesetzt werden konnte. Wurden zu dem Zeitpunkt noch nicht alle Züge gesetzt, so ist die übergebene Kombination der Züge nicht gültig, andernfalls ist die Kombination der Züge gültig. Die Funktion ist zudem in der Lage aufgeschlüsselt nach den einzelnen Zügen zurückzugeben, welche Würfel verwendet wurden und stellt dabei auch sicher, dass es dort keine Überschneidungen gibt.

\section{Zug ausführen}
Zum Ausführen eines oder mehrerer Züge dient die überladene Funktion % move()
\lstinline$move()$\footnote{\lstinline$bool BG::Backgammon::move( void );$ \file{\wdir backgammon.cpp:\ref*{src:bool:BG::Backgammon::move(void)}}\\ \lstinline$bool BG::Backgammon::move( const BG::BackgammonMove &move,$ \lstinline$BG::IllegalMove *reason = NULL, bool *dice_used = NULL );$ \file{\wdir backgammon.cpp:\ref*{src:bool:BG::Backgammon::move(const:BackgammonMove&,IllegalMove*,bool*)}}\\ \lstinline$bool BG::Backgammon::move( const std::vector< BG::BackgammonMove > &moves,$ \lstinline$BG::IllegalMove *reason = NULL, bool *dice_used = NULL );$ \file{\wdir backgammon.cpp:\ref*{src:bool:BG::Backgammon::move(const:std::vector:BackgammonMove&,IllegalMove*,bool*)}}}.
Ein einzelner Zug kann mit der Form \lstinline$move( const BG::BackgammonMove &move, ... )$ ausgeführt werden. Zum Ausführen einer beliebigen Anzahl Züge gleichzeitig dient die Form \lstinline$move( const std::vector< BG::BackgammonMove > &moves, ... )$. Ist ein Spieler zugunfähig, so kann er die zweite Form mit einem leeren Vektor oder die Form \lstinline$move( void )$ aufrufen. Sollte der übergebene Zug bzw. die Züge nicht gültig sein, so werden diese nicht ausgeführt und die Funktion gibt \lstinline$false$ zurück. Bei \lstinline$move( void )$ ist dies der Fall, wenn der Spieler gar nicht zugunfähig ist. Wurde der Zug ausgeführt wird \lstinline$true$ zurückgegeben. Weiterhin sind diese Funktionen (außer \lstinline$move( void )$ aus offensichtlichen Gründen) wie auch
\srcref{bool BG::Backgammon::}{is_valid_move}{( const BG::BackgammonMove &move,$ \lstinline$ BG::IllegalMove *reason = NULL, bool *dice_used = NULL, bool check_bar = true );}{\wdir backgammon.cpp}{bool:BG::Backgammon::is_valid_move(const:BackgammonMove&,IllegalMove*,bool*,bool)const}
und
\srcref{bool BG::Backgammon::}{are_valid_moves}{($ \lstinline$const std::vector< BG::BackgammonMove > &move, BG::IllegalMove *reason = NULL,$ \lstinline$bool **dice_used = NULL );}{\wdir backgammon.cpp}{bool:BG::Backgammon::are_valid_moves(const:std::vector:BackgammonMove&,IllegalMove*,bool**)const}
in der Lage die benutzten Augenzahlen oder den Grund, warum der Zug/die Züge ungültig sind, zurückzugeben.

Die Form \lstinline$move( void )$ prüft, ob der aktuelle Spieler zugunfähig ist und ruft in diesem Fall die Funktionen \srcref{void BG::Backgammon::}{refresh}{( void );}{\wdir backgammon.cpp}{void:BG::Backgammon::refresh(void)} und \srcref{void BG::Backgammon::}{end_turn}{( void );}{\wdir backgammon.cpp}{void:BG::Backgammon::end_turn(void)} auf. Auf diese beiden Funktionen werde ich unten etwas näher eingehen.

Die anderem beiden Funktionen der \lstinline$move()$-Funktion prüfen zuerst, ob der Zug/die Züge gültig sind und wenden sie dann einzeln mit \srcref{void BG::Backgammon::}{apply_move}{( BG::BackgammonMove move, bool dice_used[ 4 ] );}{\wdir backgammon.cpp}{void:BG::Backgammon::apply_move(BackgammonMove,bool[4])} an. Anschließend werden alle noch nicht benutzten Augenzahlen in \srcref[]{short int BG::}{m_dice}{[ 4 ];}{\wdir backgammon.h}{BG::Backgammon::m_dice} an den Anfang des Arrays verschoben. Zum Schluss folgen noch ein Aufruf der Funktion \srcref{void BG::Backgammon::}{refresh}{( void );}{\wdir backgammon.cpp}{void:BG::Backgammon::refresh(void)} und, sofern der Spieler keinen weiteren gültigen Zug ausführen kann, ein Aufruf der Funktion \srcref{void BG::Backgammon::}{end_turn}{( void );}{\wdir backgammon.cpp}{void:BG::Backgammon::end_turn(void)}.

Die Funktion \srcref{void BG::Backgammon::}{refresh}{( void );}{\wdir backgammon.cpp}{void:BG::Backgammon::refresh(void)} aktualisiert zum einen Informationen zum Spielstatus, wie z.\,B.~welcher Spieler bereits alle Spielsteine im Homeboard hat. Zum anderen wird die Funktion \srcref{bool BG::Backgammon::}{is_valid_move_possible}{( BG::BackgammonMove *move = NULL );}{\wdir backgammon.cpp}{bool:BG::Backgammon::is_valid_move_possible(BG::BackgammonMove*)} aufgerufen, damit sichergestellt ist, dass die Werte von \srcref[]{bool BG::Backgammon::}{m_dice_result_has_to_be_used}{[ 2 ];}{\wdir backgammon.h}{BG::Backgammon::m_dice_result_has_to_be_used} korrekt gesetzt sind (siehe Kapitel \ref{topic:m_dice_result_has_to_be_used}).

Mit einem Aufruf der Funktion \srcref{void BG::Backgammon::}{end_turn}{( void );}{\wdir backgammon.cpp}{void:BG::Backgammon::end_turn(void)} kommt der nächste Spieler an die Reihe.
