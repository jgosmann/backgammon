\chapter{Künstliche Intelligenz}
Die grundlegende Arbeitsweise der künstlichen Intelligenz ist folgende: Es werden alle möglichen Zugmöglichkeiten bis zum Ablauf des Timeouts durchgegangen und die Spielsituationen, die nach Setzen der Züge entstehen, mit einer Bewertungsfunktion unter Berücksichtigung verschiedener Faktoren bewertet.

Implementiert wird die KI durch die Klassen \srcref[]{class }{AI}{ : public QObject;}{\wdir ai.h}{AI} und \srcref[]{class }{AIThread}{ : public QThread;}{\wdir aithread.h}{AIThread}. Mittels letzterer wird dabei ein Thread gestartet, der die Berechnungen für die KI vornimmt, so dass die grafische Oberfläche während dieser Zeit bedienbar bleibt. Die Klasse \srcref[]{class }{AI}{ : public QObject;}{\wdir ai.h}{AI} dient dazu, den Thread einfacher zu kontrollieren und realisiert den Timeout, damit die KI spätestens nach einer bestimmten Zeit einen Zug ausführt.

Mit der Funktion \srcref{void }{AI::move}{( void );}{\wdir ai.cpp}{void:AI::move(void)} wird die KI dazu aufgefordert, zu ziehen. Dies läuft so ab, dass der Timer für den Timeout gestartet wird, anschließend wird darauf gewartet, dass der entsprechende KI-Thread \srcref[]{AIThread }{AI::m_ai_thread}{;}{\wdir ai.h}{AI::m_ai_thread} wieder im Ruhezustand ist. Das heißt, er hat alle Berechnung vom letzten Zug beendet oder abgebrochen. Dies ist wichtig, falls die gleiche Instanz der KI zweimal schnell hintereinander an die Reihe kommt, damit nicht die Berechnungen des alten Zuges auch für den neuen weiterverwendet werden. Nun wird dem KI-Thread über die Funktion \srcref{inline void }{AIThread::request}{( RequestFlag request_flag );}{\wdir aithread.h}{inline:void:AIThread::request(RequestFlag)} mitgeteilt, dass sie einen Zug suchen soll. Sobald die KI ihre Berechnungen komplett beendet hat oder das Timeout abgelaufen ist, wird die Funktion \srcref{void }{AI::do_move}{( void );}{\wdir ai.cpp}{void:AI::do_move(void)} aufgerufen, welche den besten von der KI bis zu dem Zeitpunkt gefundenen Zug ausführt.

\section{Suchen nach dem besten Zug}
Wenn der KI-Thread dazu aufgefordert wird einen möglichst günstigen Zug zu suchen, wird die Funktion \srcref{void }{AIThread::find_move}{( short int rec_depth );}{\wdir aithread.cpp}{void:AIThread::find_move(short:int)} aufgerufen, sofern der aktuelle Spieler nicht zugunfähig ist. Diese Funktion geht systematisch alle möglichen Zugkombinationen (mithilfe rekursiver Funktionsaufrufe) durch und bewertet diese. Die jeweils beste wird gespeichert, so dass nachdem alle Zugkombinationen durchgegangen wurden oder der Timeout abgelaufen ist, diese gesetzt werden kann.

Vier Variablen, die die Funktion \srcref{void AIThread::}{find_move}{( short int rec_depth = 0 );}{\wdir aithread.cpp}{void:AIThread::find_move(short:int)} verwendent, sind als private Membervariablen der Klasse \srcref[]{class }{AIThread}{ : public QThread;}{\wdir aithread.h}{AIThread} deklariert. Für eine Variable -- nämlich \srcref[]{BG::Backgammon AIThread::}{m_game_copy}{;}{\wdir aithread.h}{AIThread::m_game_copy} -- war der Grund, dass so nicht jedesmal neu Speicher für die Klasse belegt werden und diese initialisiert werden muss. Diese Variable dient dazu, wenn nötig, eine Kopie der aktuellen Spielsituation des Backgammon-Spiels aufzunehmen. Für die anderen drei Variablen \srcref[]{short int AIThread::}{m_dice}{[ 4 ];}{\wdir aithread.h}{AIThread::m_dice}, \srcref[]{short int AIThread::}{m_changes}{[ 25 ];}{\wdir aithread.h}{AIThread::m_changes} und \srcref[]{std::vector< BG::BackgammonMove > AIThread::}{m_moves}{;}{\wdir aithread.h}{AIThread::m_moves} war der Grund, dass diese so nicht bei jedem rekursiven Funktionsaufruf als Argument übergeben werden müssen. Die erste dient dazu die noch zu setzenden Augenzahlen aufzunehmen, auf die zweite werde ich etwas weiter unten eingehen und die dritte speichert die aktuell untersuchte Zugkombination beim systematischen Durchgehen der Züge.

Beim ersten noch nicht rekursiven Aufruf der Funktion werden die Variablen \srcref[]{short int AIThread::}{m_dice}{[ 4 ];}{\wdir aithread.h}{AIThread::m_dice} und \srcref[]{short int AIThread::}{m_changes}{[ 25 ];}{\wdir aithread.h}{AIThread::m_changes} zuerst initialisiert.

Als nächstens sorgt die Funktion, wenn noch kein rekursiver Aufruf stattgefunden hat, dafür, dass in \srcref[]{std::vector< BG::BackgammonMove > AIThread::}{m_best_move}{;}{\wdir aithread.h}{AIThread::m_best_move} auf jeden Fall ein kompletter, gültiger Zug gespeichert ist. Dazu wird die Funktion \srcref{bool }{BG::Backgammon::is_valid_move_possible}{( BG::BackgammonMove *move = NULL );}{\wdir backgammon.cpp}{bool:BG::Backgammon::is_valid_move_possible(BG::BackgammonMove*)} verwendet, da sie in der Lage ist gültige Züge zurückzugeben (siehe auch Kapitel \ref{topic:is_valid_move_possible}).

Anschließend wird geprüft, ob eine der folgenden Bedingungen erfüllt ist:
\begin{enumerate}
  \item \label{enum:ki:zugsuche:dice} Für die Züge in \srcref[]{std::vector< BG::BackgammonMove > AIThread::}{m_moves}{;}{\wdir aithread.h}{AIThread::m_moves} müssten alle verfügbaren Augenzahlen gesetzt werden.
  \item In \srcref[]{std::vector< BG::BackgammonMove > AIThread::}{m_moves}{;}{\wdir aithread.h}{AIThread::m_moves} sind so viele Züge, dass es eventuell mit diesen möglich ist alle Spielsteine auszuwürfeln.
  \item Die Rekursionstiefe ist größer oder gleich zwei, woraus folgt, dass in \srcref[]{std::vector< BG::BackgammonMove > AIThread::}{m_moves}{;}{\wdir aithread.h}{AIThread::m_moves} mindestens zwei Züge gespeichert sind. Dies ist nötig zu prüfen, denn z.\,B. werden bei einem Pasch auch dann alle vier Augenzahlen nach \srcref[]{short int AIThread::}{m_dice}{[ 4 ];}{\wdir aithread.h}{AIThread::m_dice} kopiert, wenn nur zwei oder drei dieser Augenzahlen gesetzt werden können. Ist dies der Fall, so kann dies nicht über Bedingung \ref{enum:ki:zugsuche:dice} festgestellt werden.
\end{enumerate}
Wenn eine dieser Bedingungen erfüllt ist, so ist es \emph{möglich}, dass die Zugkombination in \srcref[]{std::vector< BG::BackgammonMove > AIThread::}{m_moves}{;}{\wdir aithread.h}{AIThread::m_moves} ein gültiger Zug ist. Daher wird in diesem Fall eine Kopie der aktuellen Spielsituation in \srcref[]{BG::Backgammon AIThread::}{m_game_copy}{;}{\wdir aithread.h}{AIThread::m_game_copy} erstellt. Nun wird versucht die Züge in \srcref[]{std::vector< BG::BackgammonMove > AIThread::}{m_moves}{;}{\wdir aithread.h}{AIThread::m_moves} anhand der Kopie auszuführen. Wenn dies möglich ist -- die Zugkombination also eine gültige ist -- und die Zahl der Züge ausreicht, dass der nächste Spieler an die Reihe kommt, wird die Spielsituation nach Ziehen der Züge mithilfe der Bewertungsfunktion \srcref{double AIThread::}{rate_game_situation}{( const BG::Backgammon *game,$ \lstinline$BG::Player player ) const;}{\wdir aithread.cpp}{double:AIThread::rate_game_situation(const:BG::Backgammon*,BG::Player)const} bewertet. Sollte die Bewertung höher als die der Zugkombination in \srcref[]{std::vector< BG::BackgammonMove > AIThread::}{m_best_move}{;}{\wdir aithread.h}{AIThread::m_best_move} sein, so wird diese Zugkombination ersetzt. Nähere Informationen zur Bewertungsfunktion finden sich in Kapitel \ref{sec:ai:rating_function}.

Der letzte Abschnitt der Funktion dient dazu alle Zugkombinationen systematisch durchzugehen. In einer ersten Schleife werden sämtliche "`Zungen"' und die Bar durchgegangen. Sofern auf einer Zunge eigene Spielsteine sind, werden in einer weiteren Schleife die noch nicht verwendeten Augenzahlen durchgegangen. Für jede dieser Augenzahlen wird ein Zug von der entsprechenden Position und Zugweite an \srcref[]{std::vector< BG::BackgammonMove > AIThread::}{m_moves}{;}{\wdir aithread.h}{AIThread::m_moves} angehängt. Die durch diesen Zug auf dem Spielbrett entstehenden Änderungen werden mittels des Arrays \srcref[]{short int AIThread::}{m_changes}{[ 25 ];}{\wdir aithread.h}{AIThread::m_changes} gespeichert. Weiterhin wird die entsprechende Augenzahl in \srcref[]{short int AIThread::}{m_dice}{[ 4 ];}{\wdir aithread.h}{AIThread::m_dice} auf null gesetzt. Schließlich ruft sich die Funktion rekursiv auf. Anschließend wird der Zug wieder aus \srcref[]{std::vector< BG::BackgammonMove > AIThread::}{m_moves}{;}{\wdir aithread.h}{AIThread::m_moves} entfernt und auch die Änderungen an \srcref[]{short int AIThread::}{m_dice}{[ 4 ];}{\wdir aithread.h}{AIThread::m_dice} und \srcref[]{short int AIThread::}{m_changes}{[ 25 ];}{\wdir aithread.h}{AIThread::m_changes} rückgängig gemacht.

\section{Bewertungsfunktion} \label{sec:ai:rating_function}
Eine Spielsituation wird von der KI mit der Funktion \srcref{double AIThread::}{rate_game_situation}{( const BG::Backgammon *game,$ \lstinline$BG::Player player ) const;}{\wdir aithread.cpp}{double:AIThread::rate_game_situation(const:BG::Backgammon*,BG::Player)const} bewertet. Die Bewertung setzt sich aus mehreren Summanden zusammen, die mit einer Ausnahme auf einen Wert zwischen 0 und 1 normiert sind. Die Gewichtung der einzelnen Summanden lässt sich über die Werte im Array \srcref[]{double AIThread::}{m_rating_factors}{[ AIThread::NUM_RATING_FACTORS ];}{\wdir aithread.h}{AIThread::m_rating_factors} ändern. Dies ist auch wichtig, da sowohl Summanden, die positive Sachverhalte bewerten, als auch Summanden, die negative Sachverhalte bewerten, positiv sind. Daher müssen bestimmte Summanden mit einem negativen Faktor für die Gewichtung multipliziert werden. Zur besseren Verständlichkeit können die Elemente des Arrays \srcref[]{double AIThread::}{m_rating_factors}{[ AIThread::NUM_RATING_FACTORS ];}{\wdir aithread.h}{AIThread::m_rating_factors} mit den Werten der Enumeration \srcref[]{enum AIThread::}{RatingFactors}{;}{\wdir aithread.h}{AIThread::RatingFactors} angesprochen werden. Die Elemente dieser Enumeration benutze ich auch zur Benennung der einzelnen Summanden der Bewertungsfunktion nutzen, welche ich im Folgenden aufliste:
\begin{itemize}
  \item \lstinline$PROB_CHECKER_IS_HIT$: Summand für die Wahrscheinlichkeit, dass der gegnerische Spieler einen eigenen Spielstein schlagen kann. Dabei werden die Wahrscheinlichkeiten aller einzelnen eigenen Spielsteine -- also der Spielsteine, die geschlagen werden können -- addiert. Diese Wahrscheinlichkeiten werden jeweils noch mit zwei weiteren Faktoren multipliziert: Der erste Faktor gibt die Entfernung von der ersten "`Zunge"' mit einem Wert zwischen 0 (erste "`Zunge"') und 1 (letzte "`Zunge"') an. Dies ist sinnvoll, denn je näher ein Spielstein an der letzten "`Zunge"' ist, desto nachteiliger wäre es, wenn dieser geschlagen würde. Beim zweiten Faktor handelt es sich um die Wahrscheinlichkeit den Spielstein nicht wieder ins Spiel bringen zu können, wenn dieser geschlagen wird. Diese wird über die Gegenwahrscheinlichkeit bestimmt, nämlich eins minus die Wahrscheinlichkeit den Spielstein zurück ins Spiel bringen zu können. Zu diesem Faktor wird zudem noch 1 hinzuaddiert, denn ansonsten würde dieser ganze Summand in der Bewertungsfunktion null, wenn die Wahrscheinlichkeit den Spielstein ins Spiel zurückzubringen 1 beträgt.
  \item \lstinline$PROB_CANNOT_MOVE$: Bei diesem Summanden der Bewertungsfunktion wird für jeden eigenen Spielstein die Wahrscheinlichkeit aufaddiert, dass sich dieser in der nächsten Runde nicht setzen lässt (wobei nicht beachtet wird, dass der Gegner vorher noch zieht). Zudem werden diese Wahrschienlichkeiten jeweils mit einem Faktor für die Entfernung zur letzten "`Zunge"' zwischen 0 (letzte "`Zunge"') und 1 (erste "`Zunge"') multipliziert, denn wenn weit vom Homeboard entfernte Spielsteine blockiert werden ist dies wesentlich ungünstiger als wenn diese bereits nahe am Homeboard sind. In zuletzt geannter Situation muss der Gegner nämlich zwangsweise die Blockade aufgeben, um mit seinen Spielsteinen zum eigenen Homeboard zu gelangen. Bei diesem Summanden wird die Bar nicht mit einbezogen, da der Spieler sowieso gezwungen ist von dieser zu ziehen und daher keine Möglichkeit hat die Wahrscheinlichkeit, dass er mit den Spielsteinen auf der Bar nicht setzen kann, zu beeinflussen.
  \item \lstinline$PROB_OP_CANNOT_MOVE$ und \lstinline$PROB_OP_CANNOT_MOVE_BAR$: Bei diesen Summanden wird im Grunde genau das gleiche wie bei \lstinline$PROB_CANNOT_MOVE$ für den gegnerischen Spieler berechnet, nur dass diesmal mit \lstinline$PROB_OP_CANNOT_MOVE_BAR$ auch die Bar miteinbezogen wird, denn die KI kann evtl. gegnerische Spielsteine schlagen. Für diese gibt es einen eigenen Faktor für die Gewichtung, da der Gegner nicht ziehen kann, wenn Spielsteine auf der Bar sind, er diese aber nicht zurück ins Spiel bringen kann.
  \item \lstinline$N_POINTS_WITH_CHECKERS$: Weiterhin wird die Zahl der "`Zungen"' mit mindestens zwei eigenen Spielsteinen addiert. Dieser Wert wird vor der Addition noch durch 7 geteilt, da es maximal sieben solcher "`Zungen"' geben kann. Dies ist sinnvoll, da viele Zungen mit mindestens zwei eigenen Spielsteinen aus zwei Gründen nützlich sind: Zum einen werden so die Zugmöglichkeiten des Gegners eingeschränkt und zum anderen ist es wahrscheinlicher, dass Spielsteine so gesetzt werden können, dass der Gegner nicht in der Lage ist einen zu schlagen.
  \item \lstinline$BEARED_OFF$: Dieser Summand gibt einfach nur den Anteil eigener ausgewürfelter Spielsteine an.
  \item \lstinline$DISTANCE_FROM_HOMEBOARD$: Dieser Summand gibt die durchschnittliche Entfernung der Spielsteine zum Homeboard geteilt durch 18 an. Der Wert wird zur Normierung auf eine Größe zwischen 0 und 1 durch 18 geteilt, denn weiter als 18 Felder kann ein Spielstein nicht vom Homeboard entfernt sein.
  \item \lstinline$CHECKERS_IN_OP_HOMEBOARD$: Dieser Summand gibt die Zahl der eigenen Spiele im gegnerischen Homeboard und auf der Bar an (zur Normierung geteilt durch 15). Dies lasse ich mit in die Bewertung einfließen, da der Gegner mit 3 Punkten -- einem Backgammon -- gewinnen könnte, so lange sich dort Spielsteine befinden.
  \item \lstinline$OP_DISTANCE_FROM_OFF_GAME$: Mit diesem Summand wird angegeben, wieviele "`Zungen"' die Spielsteine des Gegners durchschnittlich noch gezogen werden müssen, bis diese ausgewürfelt sind. Zur Normierung auf einen Wert zwischen 0 und 1 wird durch 24 geteilt. Dieser Summand ändert sich, wenn Spielsteine des Gegners geschlagen werden und zwar um so mehr, je näher der geschlagene Spielstein bereits an der letzten "`Zunge"' war.
\end{itemize}

Durch ein Anpassen der Bewertungsfaktoren in \srcref[]{double AIThread::}{m_rating_factors}{[ AIThread::NUM_RATING_FACTORS ];}{\wdir aithread.h}{AIThread::m_rating_factors} lässt sich das Verhalten der KI ändern. In \file{\wdir ai\_std\_config.h} habe ich folgende Standardwerte deklariert:
\inputencoding{latin1}
\lstinputlisting[firstline=35,lastline=47,numbers=left,basicstyle=\fontfamily{pcr}\selectfont\small]{\basene \wdirne ai_std_config.h}
\inputencoding{utf8}
Diese habe ich vor allem dadurch ermittelt, dass ich wiederholt gegen die KI gespielt habe oder auch die KI gegen sich selbst habe spielen lassen. Mithilfe meiner Beobachtungen, an welchen Stellen die KI nicht so reagiert wie es opitmal wäre, habe ich die Werte dann schrittweise angepasst. Eine andere Methode, die ich mir überlegt habe, um die Werte automatisch anzupassen, hat leider nicht wie gewünscht funktioniert. Ich gehe dadrauf in Kapitel \ref{sec:ai-evolver} ein.

Im Folgenden werde ich noch erklären, wie die Bewertungsfunktion bestimmte Wahrscheinlichkeiten berechnet.

\subsection{Wahrscheinlichkeit, dass eine bestimmte "`Zunge"' erreicht werden kann}
Zur Berechnung der Wahrscheinlichkeit, dass der Spieler \lstinline$player$ eine bestimmte "`Zunge"', im Folgendem mit \lstinline$position$ bezeichnet, in seinem nächsten Zug erreichen kann, wird die Funktion \srcref{double AIThread::}{prob_position_is_reached}{( const BG::Backgammon *game,$ \lstinline$short int position, BG::Player player ) const;}{\wdir aithread.cpp}{double:AIThread::prob_position_is_reached(const:BG::Backgammon*,short:int,BG::Player)const} verwendet. Dazu speichert sie in dem zweidimensionalen Array \lstinline$possible_dice_combinations$, mit welchen Würfelwürfen \lstinline$position$ erreicht werden kann.

Um dies zu ermitteln, werden in einer ersten Schleife die möglichen Augenzahlen (also eins bis sechs) durchgegangen. Die "`Zunge"', die entsprechend viele Felder vor \lstinline$position$ liegt, wird mit \lstinline$checking_position$ gespeichert. Dann wird geprüft, ob auf diesem Feld ein Spielstein von \lstinline$player$ ist, dieser also \lstinline$position$ erreichen kann. Wenn dies der Fall ist, werden die Werte von \lstinline$possible_dice_combinations$ entsprechend gesetzt. Ansonsten werden -- sofern nicht mindestens zwei gegnerische Spielsteine auf \lstinline$position$ sind, in einer weiteren Schleife erneut die möglichen Augenzahlen durchgegangen und dabei \lstinline$checking_position$ jeweils auf die "`Zunge"' gesetzt, die die Entfernung beider Augenzahlen vor \lstinline$position$ liegt. Wenn auf \lstinline$checking_position$ ein eigener Spielstein ist, kann \lstinline$position$ von \lstinline$player$ erreicht werden und \lstinline$possible_dice_combinations$ wird entsprechend gesetzt. Wenn dies nicht der Fall ist, aber beide Augenzahlen gleich sind und auf \lstinline$checking_position$ nicht mehr als ein gegnerischer Spielstein ist, wird dieses Schema fortgesetzt. Allerdings werden dabei dann keine Augenzahlen mehr durchgegangen, da es sich um ein Pasch handelt und somit alle drei oder vier Augenzahlen gleich sind.

Nachdem so sämtliche Werte in \lstinline$possible_dice_combinations$ gesetzt wurden, wird dieses Array erneut durchgegangen und für jede mögliche Kombination zweier Augenzahlen, mit denen \lstinline$position$ erreicht werden könnte, $\frac{1}{36}$ zum Rückgabewert addiert, da dies die Wahrscheinlichkeit dafür ist, dass eine bestimmte Kombination zweier Augenzahlen auftritt.

\subsection{Wahrscheinlichkeit, einen Spielstein nicht setzen zu können}
Mit der Funktion \srcref{double AIThread::}{prob_player_cannot_move_at_pos}{( BG::Position pos,$ \lstinline$const BG::Backgammon *game, BG::Player player ) const;}{\wdir aithread.cpp}{double:AIThread::prob_player_cannot_move_at_pos(BG::Position,const:BG::Backgammon,BG::Player)const} wird die Wahrscheinlichkeit bestimmt, dass ein Spieler im nächsten Zug einen Spielstein nicht setzen kann. Dazu werden einfach die möglichen Augenzahlen von eins bis sechs durchgegangen und jeweils geprüft, ob sich der Spielstein damit setzen ließe. Für jede Augenzahl, für die dies möglich ist, muss $\frac{1}{6}$ zum Rückgabewert addiert werden.

\section{Verbesserungsideen}
Während der Entwicklung der KI hatte ich vor allem zwei weitere Ideen, wie man diese noch weiter verbessern könnte, abgesehen von Verbesserungen an der Bewertungsfunktion und der Gewichtung deren Summanden. Allerdings fehlte mir die Zeit diese genauer auszuarbeiten oder gar zu implementieren.

Meine erste Idee war, dass es nicht gerade optimal ist, die KI die Zugkombinationen in starrer Reihenfolge durchgehen zu lassen. Sinnvoller wäre es, wenn anfangs solche Zugkombinationen geprüft werden, bei denen die Wahrscheinlichkeit, dass sie eine hohe Bewertung erhalten, relativ hoch ist und erst anschließend die restlichen Zugkombinationen. Dies wäre gerade bei kurzen Timeout-Werten von Vorteil. Allerdings stellt sich die Frage, wie man schnell die Zugkombinationen ermittelt, welche zuerst geprüft werden sollen, denn wenn dies zu lange dauert ist die jetzige Implementierung der KI weiterhin im Vorteil.

Dieses Problem könnte evtl. durch meine zweite Idee gelöst werden: So lange der gegnerische Spieler an der Reihe ist, tut die KI nichts. Diese Zeit könnte man aber bereits für Berechnungen nutzen. So könnten z.\,B. bereits Züge für meine erste Idee rausgesucht werden.

Andererseits stellt sich die Frage, ob der Nutzen dieser beiden Ideen so groß ist, dass der Implementierungsaufwand gerechtfertigt ist. So hat die KI auf meinen Testrechnern\footnote{Die Prozessoren meiner Testsysteme waren ein AMD Athlon XP 2600+ Prozessor mit ca. 2\,GHz und ein Intel Celeron M mit ca. 1,6\,GHz.} in vielen Fällen innerhalb kürzester Zeit gezogen und das Timeout, das ich in der Regel auf 3 Sekunden eingestellt hatte, gar nicht ausgenutzt. Doch auch nicht gerade selten wurde die KI durch den Timeout unterbrochen. Gerade bei einem Pasch, wo sich die Zahl der Zugmöglichkeiten vervielfacht, ist dies eigentlich immer der Fall gewesen.

\section{ai-evolver} \label{sec:ai-evolver}
Anfangs hatte ich vor, möglichst gute Gewichtungen für die Bewertungsfunktion mit einem genetischen Algorithmus zu finden. Im Endeffekt hat dies leider nicht funktioniert und die Gewichtungen wurden zunehmend schlechter, je länger der Algorithmus lief. Trotzdem möchte ich hier etwas näher auf diesen eingehen und im Anschluss ein paar Überlegungen anstellen, was der Grund des Versagens sein könnte.

Der genetische Algorithmus, den ich implementiert habe ist einer der einfachsten. Zunächst hat man ein Ausgangsindividuum (hier bestimmte Gewichtungen) mit dem man eine Population einer bestimmten Größe erstellt. Dies geschieht, indem man Varianten des Ausgangsindividuums erstellt. Jeder einzelne Gewichtungsfaktor kann mit einer gewissen Wahrscheinlichkeit verändert werden ("`Mutationswahrscheinlichkeit"'). Wenn dies der Fall ist, wird der Wert um einen zufälligen Wert geändert, dessen maximaler Betrag festgelegt ist ("`Mutationsradius"'). Anschließend bestimmt man, welches Individuum in der Population die größte "`Fitness"' hat. In unserem Fall wäre das die Spielstärke der KI. Zur Bestimmung dieser lässt man jedes Individuum der Population gegen alle anderen ein oder mehrere Backgammon-Spiele austragen und das Individuum mit den meisten Punkten ist das mit der größten "`Fitness"'. Mit diesem Individuum bzw. diesen Gewichtungsfaktoren wird wieder eine neue Population erstellt.

Implementiert habe ich einen solchen Algorithmus mit dem Unterprojekt \name{ai-evolver} im Ordner \file{ai-evolver}. Dabei findet sich der Hauptcode in der Klasse \srcref[]{class }{AIEvolver}{ : public QCoreApplication;}{ai-evolver/aievolver.h}{AIEvolver}. Die Funktion \srcref{int AIEvolver::}{evolve}{( void );}{ai-evolver/aievolver.cpp}{int:AIEvolver::evolve(void)} implementiert den genetischen Algorithmus. Ein Backgammon-Spiel zwischen zwei Individuen bzw. zwei KIs mit unterschiedlichen Gewichtungsfaktoren wird mithilfe der Funktion \srcref{int AIEvolver::}{simulate_game}{( double *factors1, double *factors2 );}{ai-evolver/aievolver.cpp}{int:AIEvolver::simulate_game(double*,double*)} ausgetragen.

\subsection{Bedienung} \label{sec:ai-evolver:usage}
Der \name{ai-evolver} ist ein Kommandozeilen-Programm, das mit 12 oder 13 Argumenten aufgerufen werden muss. Der Aufruf lautet:
\input{ai-evolver_call}
Mit \key{Strg\,+\,C} wird das Programm beendet.

Jede Minute und immer, wenn bessere Gewichtungsfaktoren gefunden wurden, wird eine Statusmeldung ausgegeben, die auch die besten bis zu dem Zeitpunkt gefundenen Gewichtungsfaktoren enthält. Zudem wird für jedes gestartete Backgammon-Spiel eine öffnende eckige Klammer ([), für jedes beendete eine schließende eckige Klammer (]) ausgegeben. Für jeden Zug in einem Backgammon-Spiel wird ein Punkt (.) ausgegeben.

\subsection{Überlegungen, warum der Algorithmus versagt}
Das Problem ist wahrscheinlich, dass zum einen die Unterschiede zwischen den einzelnen Individuuen einer Population recht gering sind und zum anderen Backgammon eine nicht allzu geringe Zufallskomponente hat. Aufgrund des geringen Unterschieds der Gewichtungsfaktoren spielen die verschiedenen Indiviuuen fast gleich stark und durch die Zufallskomponente kann auch die KI mit den eigentlich schlechteren Gewichtungsfaktoren viele Spiele für sich entscheiden. Da die Wahrscheinlichkeit dafür wohl immer noch knapp unter 50 Prozent ist, kommt es häufig vor, dass die schlechteren Gewichtungsfaktoren als die besseren erkannt werden. Zudem ist die Wahrscheinlichkeit, dass die Faktoren nach einer "`Mutation"' besser sind relativ gering, so dass von vornherein ein Überschuss an schlechteren Gewichtungsfaktoren besteht. So werden die Faktoren fortlaufend geringfügig schlechter, da sich nicht einwandfrei sagen lässt, welche denn nun wirklich besser sind.

Lösen könnte man das Problem unter Umständen indem man die Individuuen eine deutlich größere Anzahl an Spielen gegeneinander austragen lässt oder die Populationsgröße erhöht, was ja auch wiederum zu einer Erhöhung der Anzahl der gespielten Spiele führt.\footnote{Die maximalen Werte, die ich verwendet habe waren eine Populationsgröße von 5 und jeweils 5 Spielen sowie eine Populationsgröße von 3 und jeweils 7 Spielen.} Durch die Erhöhung der Anzahl der Spiele rückt die Zufallskomponente etwas in den Hintergrund bzw. das Verhältnis der gewonnenen Spiele nähert sich dem Verhältnis der theoretischen Gewinnwahrscheinlichkeiten an (Gesetz der großen Zahl). Die Zahl der Spiele, die gegeneinander ausgetragen werden müssten, ist aber wohl so hoch, dass die benötigte Rechenzeit ins unermessliche wächst und diese Lösung somit nicht praktikabel ist.
